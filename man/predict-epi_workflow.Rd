% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/epi_workflow.R
\name{predict-epi_workflow}
\alias{predict-epi_workflow}
\alias{predict.epi_workflow}
\title{Predict from an epi_workflow}
\usage{
\method{predict}{epi_workflow}(
  object,
  new_data,
  type = NULL,
  opts = list(),
  forecast_date = NULL,
  ...
)
}
\arguments{
\item{object}{An epi_workflow that has been fit by
\code{\link[workflows:fit-workflow]{workflows::fit.workflow()}}}

\item{new_data}{A data frame containing the new predictors to preprocess
and predict on}

\item{type}{A single character value or \code{NULL}. Possible values
are "numeric", "class", "prob", "conf_int", "pred_int", "quantile", "time",
"hazard", "survival", or "raw". When \code{NULL}, \code{predict()} will choose an
appropriate value based on the model's mode.}

\item{opts}{A list of optional arguments to the underlying
predict function that will be used when \code{type = "raw"}. The
list should not include options for the model object or the
new data being predicted.}

\item{forecast_date}{The date on which the forecast is (was) made.}

\item{...}{Arguments to the underlying model's prediction
function cannot be passed here (see \code{opts}). There are some
\code{parsnip} related options that can be passed, depending on the
value of \code{type}. Possible arguments are:
\itemize{
\item \code{interval}: for \code{type}s of "survival" and "quantile", should
interval estimates be added, if available? Options are \code{"none"}
and \code{"confidence"}.
\item \code{level}: for \code{type}s of "conf_int", "pred_int", and "survival"
this is the parameter for the tail area of the intervals
(e.g. confidence level for confidence intervals).
Default value is 0.95.
\item \code{std_error}: add the standard error of fit or prediction (on
the scale of the linear predictors) for \code{type}s of "conf_int"
and "pred_int". Default value is \code{FALSE}.
\item \code{quantile}: the quantile(s) for quantile regression
(not implemented yet)
\item \code{time}: the time(s) for hazard and survival probability estimates.
}}
}
\value{
A data frame of model predictions, with as many rows as \code{new_data} has.
If \code{new_data} is an \code{epi_df} or a data frame with \code{time_value} or
\code{geo_value} columns, then the result will have those as well.
}
\description{
This is the \code{predict()} method for a fit epi_workflow object. The nice thing
about predicting from an epi_workflow is that it will:
\itemize{
\item Preprocess \code{new_data} using the preprocessing method specified when the
workflow was created and fit. This is accomplished using
\code{\link[hardhat:forge]{hardhat::forge()}}, which will apply any formula preprocessing or call
\code{\link[recipes:bake]{recipes::bake()}} if a recipe was supplied.
\item Call \code{\link[parsnip:predict.model_fit]{parsnip::predict.model_fit()}} for you using the underlying fit
parsnip model.
\item Ensure that the returned object is an \link[epiprocess:epi_df]{epiprocess::epi_df} where
possible. Specifically, the output will have \code{time_value} and
\code{geo_value} columns as well as the prediction.
}
}
\examples{

library(epiprocess)
library(dplyr)
library(parsnip)
library(recipes)

jhu <- jhu_csse_daily_subset \%>\%
  filter(time_value > "2021-08-01") \%>\%
  select(geo_value:death_rate_7d_av) \%>\%
  rename(case_rate = case_rate_7d_av, death_rate = death_rate_7d_av)

r <- epi_recipe(jhu) \%>\%
  step_epi_lag(death_rate, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(death_rate, ahead = 7) \%>\%
  step_epi_lag(case_rate, lag = c(0, 7, 14)) \%>\%
  step_naomit(all_predictors()) \%>\%
  step_naomit(all_outcomes(), skip = TRUE)

wf <- epi_workflow(r, linear_reg()) \%>\% fit(jhu)

jhu_latest <- jhu \%>\%
  filter(!is.na(case_rate), !is.na(death_rate)) \%>\%
  group_by(geo_value) \%>\%
  slice_tail(n = 15) \%>\% # have lags 0,...,14, so need 15 for a complete case
  ungroup()

preds <- predict(wf, jhu_latest, forecast_date = "2021-12-31") \%>\%
  filter(!is.na(.pred))

preds
}
